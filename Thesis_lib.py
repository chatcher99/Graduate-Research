from __future__ import divisionimport sysfrom math import*import numpy as npfrom numpy import*def Scatter(nph):        outfile_E=open('Scatter_E_Fields.dat','w')    outfile_K=open('Scatter_Vectors.dat','w')    for p in range(nph):        # first we create the incoming propagation vector K and electric field E        K=array([1,0,0])        Sigma=np.random.rand()*(pi)                   #generating random angle of E prop.         E=array([0,cos(Sigma),sin(Sigma)])        #print np.dot(E,K)                # we then rotate the frames so that the electric field is in the y direction        Ep=Rotation(E,-Sigma)        Kp=K        #print np.dot(Ep,K)                # we now generate the scattering angles          Theta=Theta_Find(100)                           #Theta is off of y axis in xy plane (probability proportional to Theta^3)        Phi=np.random.rand()*2*pi                       #Phi is off of x axis in xz plane (Randomly generated)        #Find Scattered vector        Kdp = Scatter_Vectors(Kp,Theta,Phi)                #Find Scattered EField        Edp=Scatter_EField(K,Kdp, Ep)        #print (np.dot(Edp,Kdp))                #Counter rotate scattered EField and vector        Etp=Rotation(Edp,Sigma)        Ktp=Rotation(Kdp,Sigma)        #print (np.dot(Etp,Ktp))                #create files to store vector data        writestring_E=str(Etp[0])+'\t'+str(Etp[1])+'\t'+str(Etp[2])+'\n'        outfile_E.write(writestring_E)        writestring_K=str(Ktp[0])+'\t'+str(Ktp[1])+'\t'+str(Ktp[2])+'\n'                outfile_K.write(writestring_K)            outfile_E.close()    outfile_K.close()    return def Theta_Find(num_pts):    XX=[]    for i in range(num_pts):                        #generate random x values for sine graph and scatter        x=np.random.rand()*np.pi              #same x values for both sine scatter allows for easier comparison because we can now just focus on the discrpancies in Y values        XX.append(x)    Xsine=XX                                        #sort random values so that when plotting sin it will be correct    Ysine=np.sin(Xsine)**3                       #generates y values for sin^3 graph    YY=[]    for t in range(len(Xsine)):                     #generates random y value for random scatter, for every X value.         y=np.random.rand()                           YY.append(y)    Xscat=[]            Yscat=[]    for i in range(len(YY)):                        #compares y values of scatter to y values of sin at cooresponding x values        if YY[i]<= Ysine[i]:            Yscat.append(YY[i])            Xscat.append(Xsine[i])    Theta=Xscat[0]    #print "Theta: "+str(Theta)    return Thetadef Scatter_Vectors(K,Theta,Phi):        Kxx=sin(Theta)*cos(Phi)    Kyy=cos(Theta)    Kzz=sin(Theta)*sin(Phi)        Kdp=(Kxx,Kyy,Kzz)                                #Scatter Vector    return np.array(Kdp)def Scatter_EField(K,Kdp,Ep):        L=np.cross(Kdp,Ep)                                 #vector orthoganal to the plane formed by E and KK        Lx=L[0]    Ly=L[1]    Lz=L[2]    Kxx=Kdp[0]    Kyy=Kdp[1]    Kzz=Kdp[2]    Exx= (1/(1+((Ly*(Kxx-(Lx*Kzz/Lz)))/(Lz*(Kyy-(Ly*Kzz/Lz))))**2+(-(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz)))**2))**(1/2)    Eyy= - Exx*(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz))    Ezz= (Exx/Lz)*((Ly*(Kxx-(Lx*Kzz/Lz))/(Kyy-(Ly*Kzz/Lz)))-Lx)    Edp=np.array([Exx,Eyy,Ezz])    Edp=Edp/np.sqrt(np.sum(Edp**2))                                   #E field of propogation    return Edpdef Rotation(E,Sigma):    Rotate=np.matrix([[1,0,0],[0,np.cos(Sigma),np.sin(Sigma)],[0,-np.sin(Sigma),np.cos(Sigma)]])    Erotate=E*Rotate    Erotate2=np.empty(3)    Erotate2[0]=Erotate[0,0]    Erotate2[1]=Erotate[0,1]    Erotate2[2]=Erotate[0,2]    return Erotate2def EField_Comps(Detect,nph):    #Select Vectors in Direction of Detector     kx,ky,kz=loadtxt('Scatter_Vectors.dat',unpack=True)    Ex,Ey,Ez=loadtxt('Scatter_E_Fields.dat',unpack=True)    outfile_SV=open('Selected_Vectors.dat','w')    outfile_SE=open('Selected_EFields.dat','w')        #Detect=np.array([0.001,0.001,1])    #print "Detector: " +str(Detect)    DetLength=np.linalg.norm(Detect)    DFD=5                  #degrees off of detector vector that are accepted    i=0    while i < nph:        vect=np.array([kx[i],ky[i],kz[i]])        VectLength=np.linalg.norm(vect)        a=(np.dot(vect,Detect))/(DetLength*VectLength)        omega=np.arccos(a)        if omega <= np.deg2rad(DFD):            writestring_SV=str(kx[i])+'\t'+str(ky[i])+'\t'+str(kz[i])+'\n'            outfile_SV.write(writestring_SV)            writestring_SE=str(Ex[i])+'\t'+str(Ey[i])+'\t'+str(Ez[i])+'\n'            outfile_SE.write(writestring_SE)        i+=1    outfile_SV.close()    outfile_SE.close()    x,y,z=loadtxt('Selected_Vectors.dat',unpack=True)    Ex,Ey,Ez=loadtxt('Selected_EFields.dat',unpack=True)    #Find EField Compents in Detector Reference Frame    outfile_EC=open('EField_Comps.dat','w')    D=Detect    XD=np.array((1/(D[0]**2+D[1]**2+D[2]**2))**(1/2)*D)                                        #direction of detector=xaxis of detector reference frame=line through back of detector    ZD=np.array([ (-sign(XD[0])*XD[2]/(XD[0]**2+XD[2]**2)**(1/2)) , 0 , (1-(XD[2]**2/(XD[0]**2+XD[2]**2)))**(1/2) ])     #z axis of the detector    Zy= (1/((XD[0]**2/XD[2]**2)+((XD[0]**2+XD[2]**2)**2/(XD[1]**2*XD[2]**2))+1))**(1/2)    YD=np.array([(Zy*XD[0]/XD[2]), -((Zy/XD[1])*((XD[0]**2+XD[2]**2)/XD[2])), Zy])     #is the yaxis of the detector reference frame    #print "Number of Photons: " +str(len(Ex))    for i in range(Ex.size):        E=(Ex[i],Ey[i],Ez[i])        Ecx=np.dot(E,XD)/np.linalg.norm(XD)        Ecy=np.dot(E,YD)/np.linalg.norm(YD)        Ecz=np.dot(E,ZD)/np.linalg.norm(ZD)        writestring_EC=str(Ecx)+'\t'+str(Ecy)+'\t'+str(Ecz)+'\n'        outfile_EC.write(writestring_EC)                    Ep=(Ecx,Ecy,Ecz)    outfile_EC.close()    return def Stokes(EFieldComps):    #Calculate componets of Efields on each axis    Ecx,Ecy,Ecz=loadtxt('EField_Comps.dat', unpack=True)    outfile_P=open('Polarization.dat','w')            a=array([sqrt(2),sqrt(2)])          #rotates axes    b=array([sqrt(2),-sqrt(2)])    EZ=np.zeros([Ecx.size])    EY=np.zeros([Ecx.size])    Ea=np.zeros([Ecx.size])    Eb=np.zeros([Ecx.size])            for i in range(Ecx.size):        Ec=array([Ecy[i], Ecz[i]])        EZ[i]=Ecz[i]        EY[i]=Ecy[i]        Ea[i]=np.dot(Ec,a)        Eb[i]=np.dot(Ec,b)    #Compute Stokes Parameters    EZ2=EZ**2    EY2=EY**2    Ea2=Ea**2    Eb2=Eb**2    I=sum(EZ2)/Ecx.size + sum(EY2)/Ecx.size    Q=sum(EZ2)/Ecx.size - sum(EY2)/Ecx.size    U=sum(Ea2)/Ecx.size - sum(Eb2)/Ecx.size    P=np.sqrt(Q**2+U**2)/I    outfile_P.write(str(P))    outfile_P.close()    return P